import _maxBy from "lodash/maxBy";
import _sumBy from "lodash/sumBy";
import _defaults from "lodash/defaults";
import _isEmpty from "lodash/isEmpty";
import _merge from "lodash/merge";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*eslint no-magic-numbers: ["error", { "ignore": [1, 2, 2.5, 3] }]*/
import React from "react";
import PropTypes from "prop-types";

import CustomPropTypes from "../victory-util/prop-types";
import Style from "../victory-util/style";
import TextSize from "../victory-util/textsize";
import Helpers from "../victory-util/helpers";
import VictoryLabel from "../victory-label/victory-label";
import VictoryContainer from "../victory-container/victory-container";
import VictoryTheme from "../victory-theme/victory-theme";
import Point from "../victory-primitives/point";

var defaultLegendData = [{ name: "Series 1" }, { name: "Series 2" }];

var VictoryLegend = function (_React$Component) {
  _inherits(VictoryLegend, _React$Component);

  function VictoryLegend() {
    _classCallCheck(this, VictoryLegend);

    return _possibleConstructorReturn(this, (VictoryLegend.__proto__ || Object.getPrototypeOf(VictoryLegend)).apply(this, arguments));
  }

  _createClass(VictoryLegend, [{
    key: "calculateLegendHeight",
    value: function calculateLegendHeight(textSizes, padding, isHorizontal) {
      var _props = this.props,
          gutter = _props.gutter,
          itemsPerRow = _props.itemsPerRow;

      var itemCount = textSizes.length;
      var rowCount = itemsPerRow ? Math.ceil(itemCount / itemsPerRow) : 1;
      var contentHeight = isHorizontal ? _maxBy(textSizes, "height").height * rowCount + gutter * (rowCount - 1) : (_sumBy(textSizes, "height") + gutter * (itemCount - 1)) / rowCount;

      return padding.top + contentHeight + padding.bottom;
    }

    // eslint-disable-next-line max-params

  }, {
    key: "calculateLegendWidth",
    value: function calculateLegendWidth(itemCount, padding, isHorizontal, maxTextWidth) {
      var _props2 = this.props,
          gutter = _props2.gutter,
          itemsPerRow = _props2.itemsPerRow,
          symbolSpacer = _props2.symbolSpacer;

      var rowCount = itemsPerRow ? Math.ceil(itemCount / itemsPerRow) : 1;
      var rowItemCount = itemsPerRow || itemCount;
      var contentWidth = void 0;

      if (isHorizontal) {
        var gutterWidth = gutter * rowItemCount;
        var symbolWidth = symbolSpacer * 3 * rowItemCount;
        var textWidth = maxTextWidth * rowItemCount;
        contentWidth = symbolWidth + textWidth + gutterWidth;
      } else {
        contentWidth = (maxTextWidth + symbolSpacer * 2 + gutter) * rowCount;
      }

      return padding.left + contentWidth + padding.right;
    }
  }, {
    key: "getColorScale",
    value: function getColorScale(theme) {
      var colorScaleOptions = this.props.colorScale || theme.colorScale;
      if (typeof colorScaleOptions === "string") {
        colorScaleOptions = Style.getColorScale(colorScaleOptions);
      }
      return !_isEmpty(theme) ? colorScaleOptions || theme.colorScale : colorScaleOptions || [];
    }
  }, {
    key: "getCalculatedProps",
    value: function getCalculatedProps() {
      var _this2 = this;

      // eslint-disable-line max-statements
      var role = this.constructor.role;
      var _props3 = this.props,
          data = _props3.data,
          orientation = _props3.orientation,
          theme = _props3.theme;

      var legendTheme = theme && theme[role] ? theme[role] : {};
      var parentStyles = this.getStyles({}, legendTheme, "parent");
      var colorScale = this.getColorScale(legendTheme);
      var isHorizontal = orientation === "horizontal";
      var symbolStyles = [];
      var labelStyles = [];
      var _props4 = this.props,
          height = _props4.height,
          padding = _props4.padding,
          width = _props4.width;

      var maxTextWidth = 0;

      padding = Helpers.getPadding({ padding: padding || theme.padding });
      height = Helpers.evaluateProp(height || theme.height, data);
      width = Helpers.evaluateProp(width || theme.width, data);

      var textSizes = data.map(function (datum, i) {
        var labelStyle = _this2.getStyles(datum, legendTheme, "labels");
        var textSize = TextSize.approximateTextSize(datum.name, labelStyle);
        maxTextWidth = textSize.width > maxTextWidth ? textSize.width : maxTextWidth;
        symbolStyles[i] = _this2.getStyles(datum, legendTheme, "symbol", colorScale[i]);
        labelStyles[i] = labelStyle;
        return textSize;
      });

      if (!height) {
        height = this.calculateLegendHeight(textSizes, padding, isHorizontal);
      }
      if (!width) {
        width = this.calculateLegendWidth(textSizes.length, padding, isHorizontal, maxTextWidth);
      }

      return Object.assign({}, this.props, {
        isHorizontal: isHorizontal,
        height: height,
        labelStyles: labelStyles,
        maxTextWidth: maxTextWidth,
        padding: padding,
        parentStyles: parentStyles,
        symbolStyles: symbolStyles,
        width: width
      });
    }
  }, {
    key: "getStyles",
    value: function getStyles(datum, theme, key, color) {
      // eslint-disable-line max-params
      var style = this.props.style;

      var styleKey = key === "symbol" ? "data" : key;
      var colorScaleStyle = color ? { fill: color } : {};
      var styles = _merge({}, theme.style[styleKey], colorScaleStyle, style[styleKey], datum[key]);
      return Helpers.evaluateStyle(styles, datum);
    }
  }, {
    key: "getSymbolSize",
    value: function getSymbolSize(datum, fontSize) {
      return datum.symbol && datum.symbol.size ? datum.symbol.size : fontSize / 2.5;
    }
  }, {
    key: "getSymbolProps",
    value: function getSymbolProps(datum, props, i) {
      var dataComponent = props.dataComponent,
          gutter = props.gutter,
          isHorizontal = props.isHorizontal,
          itemsPerRow = props.itemsPerRow,
          labelStyles = props.labelStyles,
          maxTextWidth = props.maxTextWidth,
          padding = props.padding,
          symbolSpacer = props.symbolSpacer,
          symbolStyles = props.symbolStyles;
      var fontSize = labelStyles[i].fontSize;

      var symbolShift = fontSize / 2;
      var style = symbolStyles[i];
      var rowHeight = fontSize + gutter;
      var itemIndex = i;
      var rowSpacer = 0;
      var rowIndex = 0;

      if (itemsPerRow) {
        rowIndex = Math.floor(i / itemsPerRow);
        rowSpacer = rowHeight * rowIndex;
        itemIndex = i % itemsPerRow;
      }

      var symbolCoords = isHorizontal ? {
        x: padding.left + symbolShift + (fontSize + symbolSpacer + maxTextWidth + gutter) * itemIndex,
        y: padding.top + symbolShift + rowSpacer
      } : {
        x: padding.left + symbolShift + (rowHeight + maxTextWidth) * rowIndex,
        y: padding.top + symbolShift + rowHeight * itemIndex
      };

      return _defaults({}, dataComponent.props, _extends({
        key: "symbol-" + i,
        style: style,
        size: this.getSymbolSize(datum, fontSize),
        symbol: style.type
      }, symbolCoords));
    }
  }, {
    key: "getLabelProps",
    value: function getLabelProps(datum, props, i) {
      var gutter = props.gutter,
          isHorizontal = props.isHorizontal,
          itemsPerRow = props.itemsPerRow,
          labelComponent = props.labelComponent,
          labelStyles = props.labelStyles,
          maxTextWidth = props.maxTextWidth,
          padding = props.padding,
          symbolSpacer = props.symbolSpacer;


      var style = labelStyles[i];
      var fontSize = style.fontSize;

      var symbolShift = fontSize / 2;
      var rowHeight = fontSize + gutter;
      var symbolWidth = fontSize + symbolSpacer;
      var itemIndex = i;
      var rowSpacer = 0;
      var rowIndex = 0;

      if (itemsPerRow) {
        rowIndex = Math.floor(i / itemsPerRow);
        rowSpacer = rowHeight * rowIndex;
        itemIndex = i % itemsPerRow;
      }

      var labelCoords = isHorizontal ? {
        x: padding.left + symbolWidth * (itemIndex + 1) + (maxTextWidth + gutter) * itemIndex,
        y: padding.top + symbolShift + rowSpacer
      } : {
        x: padding.left + symbolWidth + (rowHeight + maxTextWidth) * rowIndex,
        y: padding.top + symbolShift + rowHeight * itemIndex
      };

      return _defaults({}, labelComponent.props, _extends({
        key: "label-" + i,
        style: style,
        text: datum.name
      }, labelCoords));
    }
  }, {
    key: "renderLegendItems",
    value: function renderLegendItems(props) {
      var _this3 = this;

      var data = props.data,
          dataComponent = props.dataComponent,
          labelComponent = props.labelComponent;

      var legendData = _isEmpty(data) ? defaultLegendData : data;

      var dataComponents = legendData.map(function (datum, i) {
        return React.cloneElement(dataComponent, _this3.getSymbolProps(datum, props, i));
      });
      var labelComponents = legendData.map(function (datum, i) {
        return React.cloneElement(labelComponent, _this3.getLabelProps(datum, props, i));
      });

      return [].concat(_toConsumableArray(dataComponents), _toConsumableArray(labelComponents));
    }
  }, {
    key: "renderGroup",
    value: function renderGroup(props, children) {
      var groupComponent = props.groupComponent,
          height = props.height,
          parentStyles = props.parentStyles,
          standalone = props.standalone,
          width = props.width,
          x = props.x,
          y = props.y;

      var groupProps = { role: "presentation" };

      if (!standalone) {
        groupProps = _extends({
          height: height,
          width: width,
          transform: "translate(" + x + ", " + y + ")",
          style: parentStyles
        }, groupProps);
      }

      return React.cloneElement(groupComponent, groupProps, children);
    }
  }, {
    key: "renderContainer",
    value: function renderContainer(props, children) {
      var containerComponent = props.containerComponent,
          height = props.height,
          parentStyles = props.parentStyles,
          width = props.width;

      return React.cloneElement(containerComponent, { height: height, width: width, style: parentStyles }, children);
    }
  }, {
    key: "render",
    value: function render() {
      var props = this.getCalculatedProps();
      var group = this.renderGroup(props, this.renderLegendItems(props));
      return props.standalone ? this.renderContainer(props, group) : group;
    }
  }]);

  return VictoryLegend;
}(React.Component);

VictoryLegend.displayName = "VictoryLegend";
VictoryLegend.role = "legend";
VictoryLegend.propTypes = {
  colorScale: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.oneOf(["grayscale", "qualitative", "heatmap", "warm", "cool", "red", "green", "blue"])]),
  containerComponent: PropTypes.element,
  data: PropTypes.arrayOf(PropTypes.shape({
    name: PropTypes.string.isRequired,
    label: PropTypes.object,
    symbol: PropTypes.object
  })),
  dataComponent: PropTypes.element,
  groupComponent: PropTypes.element,
  gutter: PropTypes.number,
  height: PropTypes.oneOfType([CustomPropTypes.nonNegative, PropTypes.func]),
  itemsPerRow: PropTypes.number,
  labelComponent: PropTypes.element,
  orientation: PropTypes.oneOf(["horizontal", "vertical"]),
  padding: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    top: PropTypes.number,
    bottom: PropTypes.number,
    left: PropTypes.number,
    right: PropTypes.number
  })]),
  standalone: PropTypes.bool,
  style: PropTypes.shape({
    data: PropTypes.object,
    labels: PropTypes.object,
    parent: PropTypes.object
  }),
  symbolSpacer: PropTypes.number,
  theme: PropTypes.object,
  width: PropTypes.oneOfType([CustomPropTypes.nonNegative, PropTypes.func]),
  x: PropTypes.number,
  y: PropTypes.number
};
VictoryLegend.defaultProps = {
  data: defaultLegendData,
  containerComponent: React.createElement(VictoryContainer, null),
  dataComponent: React.createElement(Point, null),
  groupComponent: React.createElement("g", null),
  gutter: 10,
  labelComponent: React.createElement(VictoryLabel, null),
  orientation: "vertical",
  standalone: true,
  style: {},
  symbolSpacer: 8,
  theme: VictoryTheme.grayscale,
  x: 0,
  y: 0
};
export default VictoryLegend;